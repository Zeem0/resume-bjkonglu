## 状态管理与容错机制

### 状态管理的基本概念

#### 什么是状态
为了说明什么是状态，我们先来看两个例子，第一个例子就是无状态计算的例子（消费延时计算）。在一个消息队列里，一个生产者持续写入数据，同时多个消费组分别消费数据，如下图所示，然后让我们实现实时统计每个消费者消费积压值需求。

![无状态计算例子]()

针对这样的需求，我们只需要在一个操作算子里对每条数据执行减法操作，例如*consumer0 - producer*就可以得到consumer0的消费积压值，不需要依赖其他。这样就是一个无状态的计算。
```
输入数据：
{
    "timestamp": 1555516800,
    "offset":
    {
        "producer": 15,
        "consumer0": 10,
        "consumer1": 7,
        "consumer2": 12
} }

输出数据：
{
    "timestamp": 1555516800,
    "lag":
    {
        "consumer0": 5,
        "consumer1": 8,
        "consumer2": 3
} }
```

下面我们再看看有状态计算的例子（访问量统计），通过nginx访问日志（每个请求访问一个URL地址），如下图所示，实时计算统计每个地址总共被访问次数的需求。

![有状态计算例子]()

当我们实现这个需求时，通过算子去处理单条数据，不能得到完整的计算结果，依赖之前计算的结果，而这个之前的计算结果就是我们说的*状态*。
```
输入数据：
[{
    "@timestamp": "18/Apr/2019:00:00:00",
    "remote_addr": "127.0.0.1",
    "request": "GET",
    "url": "/api/a"
}, {
    "@timestamp": "18/Apr/2019:00:00:01",
    "remote_addr": "127.0.0.1",
    "request": "POST",
    "url": "/api/b"
}, {
    "@timestamp": "18/Apr/2019:00:00:00",
    "remote_addr": "127.0.0.1",
    "request": "GET",
    "url": "/api/a"
}]

输出数据：
[{
    "url": "/api/a",
    "count": 1
}, {
    "url": "/api/b",
    "count": 1
}, {
    "url": "/api/a",
    "count": 2 }]
```

知道了什么是状态，那么我们平时都在什么时候去使用状态呢？下面我们罗列一下使用状态的场景：
- 去重：通过状态记录所有的主键实现
- 窗口计算： 已进入的未触发的数据
- 机器学习/深度学习： 训练的模型及参数
- 访问历史数据：需要与历史进行对比

### 状态的类型与使用示例

### 容错机制与故障恢复
